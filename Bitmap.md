# Bitmap

bitmap是种常用的数据结构，结合hashmap，对海量的数据处理、 数据压缩等方面广泛运用 

### bitmap原理

bitmap的基本原理就是使用一个bit来存放某种状态，适用于大规模数据，但数据状态不是很多的情况，通常用来判断某个数据存不存在。

举例说明，在Java中一个int类型占4个字节，32bit，大多数时候一个int表示一个整数，但其实可以用bit的话就可以存储32个状态。

如果是1G内存，换算bit = 1024 * 1024 * 1024 * 8 = 8589934592约86亿。GB=>MB=>KB=>Byte=>Bit。如果存储int类型，能存 1024 * 1024 * 1024  * 8 / 32 约等于2亿6千万个int。

从上述结果看面对大量数据时，使用bit存储，可以在很大程度节约空间。

如果想查找或者排序的总数是N=10000，那么申请的数组大小：

int：`int temp[] = new int[1 + N/32] `，也就是312+1 = 313

long：`long temp[] = new long[1 +n/64]`，156 + 1 = 157

这里需要注意使用的语言中除法是向下还是向上取整，例子中使用的Java是向下取整，所以数组长度+1。

这里以int为例，生成bitmap：

```java
a[0] -------------> 0-31 -> bit表示[00000000000000000000000000000000]
a[1] -------------> 31-63 -> bit表示[00000000000000000000000000000000]
a[2] -------------> 64-95 -> bit表示[00000000000000000000000000000000]
```

申请一个一维数组，可以当做列为32位的二维数组。通过对32做除法，得到数组下标，然后将结果十进制转二进制，进行移位计算表示状态

例子：对一个元素不重复的数组排序

```java
BitSet map = new BitSet();
Sysetm.out.println(map.size());
int a[] = {2,3,14,7,0};
//给map赋值
 for (int num : a){
 	map.set(num, true);
 }
 
 //排序
 for (int i=0; i< map.size(); i++){
 	if (map.get(i)){
 		System.out,println(i+" ");
 	}
 }
 
output:
64
0 2 3 7 14
```

64是bit数，因为是用的Java.Util.BitSet，底层使用long类型存储元素。 且a里面没有大于63的，所以只用一个long就能解决。

bitmap的排序和计数排序原理类似（***计数排序原理不清楚***），不同的是bitmap占用的空间更小，但是bitmap缺点是不支持重复的数字排序。

例如：给定40亿个QQ号，对其去重，相同的QQ只保留一个，内存限制1G

解：用512MB就足够存储40亿QQ号码，QQ号码理论最大值是2^32-1大约43亿左右。用bitmap做个遍历，把存在的设置成1，然后判断即可



### bitmap缺点

1. 数据碰撞，比如把字符串映射到BitMap的时候会有碰撞问题，那就可以考虑用Bloom Filter解决，Bloom Filter使用多个Hash函数来减少冲突概率。
2. 数据稀疏，比如要存（10, 8887980， 912438191）这种间隔很大的数据